<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Virtual Algebra Tiles</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/DragControls.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Montserrat', sans-serif;
            background: linear-gradient(135deg, #005AA7 0%, #FFFDE4 100%);
            overflow: hidden; /* Prevent scrolling */
        }
        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .ui-container {
            position: absolute;
            z-index: 2;
            width: 100%;
            padding: 1rem;
            pointer-events: none; /* Allow clicks to pass through to canvas */
        }
        .ui-element {
            pointer-events: auto; /* Re-enable pointer events for UI elements */
        }
        .glassmorphism {
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        /* Custom button style for the requested color */
        .btn-primary {
            background-color: #005AA7;
            color: white;
        }
        .btn-primary:hover {
            background-color: #004c8f;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div id="canvas-container"></div>

    <!-- Top UI: Equation Input and Display -->
    <div class="ui-container top-0 left-0 flex justify-center">
        <div class="ui-element glassmorphism p-4 rounded-lg shadow-lg text-center w-full max-w-2xl">
            <h1 class="text-2xl font-bold mb-2">3D Algebra Tile Lab</h1>
            <div class="flex flex-col sm:flex-row items-center justify-center gap-2">
                <input type="text" id="equation-input" class="bg-white text-gray-800 border border-gray-300 px-4 py-2 rounded-md w-full sm:w-64 text-center" placeholder="e.g., 2x + 1 = 5">
                <button id="set-equation-btn" class="btn-primary px-4 py-2 rounded-md font-semibold w-full sm:w-auto">Set Equation</button>
                <button id="reset-btn" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-md font-semibold w-full sm:w-auto">Reset</button>
            </div>
            <p id="equation-display" class="mt-4 text-3xl font-mono text-gray-900">_ = _</p>
        </div>
    </div>

    <!-- Bottom UI: Tile Controls -->
    <div class="ui-container bottom-0 left-0 flex justify-center">
        <div class="ui-element glassmorphism p-4 rounded-lg shadow-lg flex flex-wrap justify-center gap-2">
            <button class="tile-btn bg-green-500 hover:bg-green-600 text-white p-2 rounded-md" data-type="x">+x</button>
            <button class="tile-btn bg-red-500 hover:bg-red-600 text-white p-2 rounded-md" data-type="-x">-x</button>
            <button class="tile-btn bg-yellow-400 hover:bg-yellow-500 p-2 rounded-md text-black" data-type="1">+1</button>
            <button class="tile-btn bg-pink-500 hover:bg-pink-600 text-white p-2 rounded-md" data-type="-1">-1</button>
        </div>
    </div>
    
    <!-- Message Box -->
    <div id="message-box" class="ui-element absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white p-6 rounded-lg shadow-2xl text-center hidden border border-gray-200">
        <p id="message-text" class="text-xl font-semibold text-gray-800"></p>
        <button id="message-ok-btn" class="mt-4 btn-primary px-4 py-2 rounded-md">OK</button>
    </div>

    <script type="module">
        // --- Basic Setup ---
        let scene, camera, renderer, orbitControls, dragControls;
        let draggableObjects = [];
        const canvasContainer = document.getElementById('canvas-container');

        // --- Tile Constants ---
        const TILE_DIMENSIONS = {
            x: { width: 5, height: 1, depth: 1 },
            '1': { width: 1, height: 1, depth: 1 }
        };
        const TILE_COLORS = {
            x: 0x22c55e,  // green-500
            '-x': 0xef4444, // red-500
            '1': 0xfacc15,  // yellow-400
            '-1': 0xec4899  // pink-500
        };
        const TILE_Y_POS = 0.5;
        const LEFT_SIDE_X = -10;
        const RIGHT_SIDE_X = 10;
        const GRID_SNAP = 1;

        // --- State ---
        let tiles = [];

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf1f5f9); // gray-100

            // Camera
            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 15, 20);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            canvasContainer.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Controls
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            
            // Drag Controls
            dragControls = new THREE.DragControls(draggableObjects, camera, renderer.domElement);
            dragControls.addEventListener('dragstart', () => orbitControls.enabled = false);
            dragControls.addEventListener('dragend', (event) => {
                snapToGrid(event.object);
                checkForZeroPairs(event.object);
                updateEquationDisplay();
                orbitControls.enabled = true;
            });

            // Ground and Center Line
            const gridHelper = new THREE.GridHelper(40, 40, 0xcccccc, 0xcccccc);
            scene.add(gridHelper);
            
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 });
            const points = [new THREE.Vector3(0, 0.01, -20), new THREE.Vector3(0, 0.01, 20)];
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const centerLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(centerLine);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('set-equation-btn').addEventListener('click', setEquationFromInput);
            document.getElementById('reset-btn').addEventListener('click', reset);
            document.querySelectorAll('.tile-btn').forEach(btn => {
                btn.addEventListener('click', () => addTilePair(btn.dataset.type));
            });
            document.getElementById('message-ok-btn').addEventListener('click', hideMessage);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        }

        // --- Tile Management ---
        function createTile(type, position) {
            const isX = type.includes('x');
            const dim = isX ? TILE_DIMENSIONS.x : TILE_DIMENSIONS['1'];
            const geometry = new THREE.BoxGeometry(dim.width, dim.height, dim.depth);
            const material = new THREE.MeshStandardMaterial({ color: TILE_COLORS[type], roughness: 0.5, metalness: 0.1 });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.copy(position);
            mesh.castShadow = true;
            mesh.userData = { type: type, value: getValueFromType(type) };
            
            scene.add(mesh);
            tiles.push(mesh);
            draggableObjects.push(mesh);
            
            return mesh;
        }
        
        function getValueFromType(type) {
            switch (type) {
                case 'x': return { x: 1, const: 0 };
                case '-x': return { x: -1, const: 0 };
                case '1': return { x: 0, const: 1 };
                case '-1': return { x: 0, const: -1 };
                default: return { x: 0, const: 0 };
            }
        }

        function removeTile(tile) {
            scene.remove(tile);
            tile.geometry.dispose();
            tile.material.dispose();
            
            // Remove from arrays
            let index = tiles.indexOf(tile);
            if (index > -1) tiles.splice(index, 1);
            
            index = draggableObjects.indexOf(tile);
            if (index > -1) draggableObjects.splice(index, 1);
        }

        function snapToGrid(tile) {
            tile.position.x = Math.round(tile.position.x / GRID_SNAP) * GRID_SNAP;
            tile.position.z = Math.round(tile.position.z / GRID_SNAP) * GRID_SNAP;
            tile.position.y = TILE_Y_POS;

            // Keep tiles on their own side
            if (tile.position.x === 0) {
                 tile.position.x = tile.userData.initialX < 0 ? -1 : 1;
            }
            if (tile.userData.initialX < 0 && tile.position.x > 0) {
                tile.position.x = -1;
            } else if (tile.userData.initialX > 0 && tile.position.x < 0) {
                tile.position.x = 1;
            }
        }

        // --- Equation Logic ---
        function parseEquation(eqString) {
            try {
                const sides = eqString.replace(/\s/g, '').split('=');
                if (sides.length !== 2) return null;

                const parseSide = (sideStr) => {
                    let x = 0;
                    let constant = 0;
                    const terms = sideStr.match(/([+-]?[^-+]+)/g) || [];
                    terms.forEach(term => {
                        if (term.includes('x')) {
                            if (term === 'x' || term === '+x') x += 1;
                            else if (term === '-x') x -= 1;
                            else x += parseInt(term.replace('x', ''), 10);
                        } else {
                            constant += parseInt(term, 10);
                        }
                    });
                    return { x, const: constant };
                };

                return {
                    left: parseSide(sides[0]),
                    right: parseSide(sides[1])
                };
            } catch (error) {
                console.error("Invalid equation format", error);
                return null;
            }
        }

        function setEquationFromInput() {
            const input = document.getElementById('equation-input').value;
            if (!input) {
                showMessage("Please enter an equation.");
                return;
            }
            const parsed = parseEquation(input);
            if (!parsed) {
                showMessage("Invalid equation format. Use 'ax + b = cx + d'.");
                return;
            }
            
            reset();
            
            generateTilesForSide(parsed.left, LEFT_SIDE_X);
            generateTilesForSide(parsed.right, RIGHT_SIDE_X);
            
            updateEquationDisplay();
        }

        function generateTilesForSide(side, xOffset) {
            // Generate x tiles
            for (let i = 0; i < Math.abs(side.x); i++) {
                const type = side.x > 0 ? 'x' : '-x';
                const pos = new THREE.Vector3(xOffset + (Math.random() - 0.5) * 5, TILE_Y_POS, (i - Math.abs(side.x)/2) * 2);
                const tile = createTile(type, pos);
                tile.userData.initialX = xOffset;
            }
            // Generate constant tiles
            for (let i = 0; i < Math.abs(side.const); i++) {
                const type = side.const > 0 ? '1' : '-1';
                const pos = new THREE.Vector3(xOffset + (Math.random() - 0.5) * 5 + 5, TILE_Y_POS, (i - Math.abs(side.const)/2) * 2);
                const tile = createTile(type, pos);
                tile.userData.initialX = xOffset;
            }
        }

        function updateEquationDisplay() {
            let left = { x: 0, const: 0 };
            let right = { x: 0, const: 0 };

            tiles.forEach(tile => {
                const side = tile.position.x < 0 ? left : right;
                side.x += tile.userData.value.x;
                side.const += tile.userData.value.const;
            });

            const formatSide = (side) => {
                let parts = [];
                if (side.x !== 0) parts.push(`${side.x}x`);
                if (side.const !== 0) parts.push(side.const > 0 ? `+ ${side.const}` : `- ${Math.abs(side.const)}`);
                if (parts.length === 0) return '0';
                return parts.join(' ').replace(/^\+ /, '');
            };

            document.getElementById('equation-display').textContent = `${formatSide(left)} = ${formatSide(right)}`;
            
            // Check for solution
            if ((left.x === 0 && right.const === 0 && right.x !== 0) || (right.x === 0 && left.const === 0 && left.x !== 0)) {
                const xSide = left.x !== 0 ? left : right;
                const constSide = right.x === 0 ? right : left;
                if (xSide.x !== 0 && constSide.const % xSide.x === 0) {
                     const solution = constSide.const / xSide.x;
                     showMessage(`Solved! x = ${solution}`);
                }
            }
        }
        
        function addTilePair(type) {
            // Add a tile to the left side
            const leftPos = new THREE.Vector3(LEFT_SIDE_X + (Math.random() - 0.5) * 5, TILE_Y_POS, (Math.random() - 0.5) * 10);
            const leftTile = createTile(type, leftPos);
            leftTile.userData.initialX = LEFT_SIDE_X;

            // Add a tile to the right side
            const rightPos = new THREE.Vector3(RIGHT_SIDE_X + (Math.random() - 0.5) * 5, TILE_Y_POS, (Math.random() - 0.5) * 10);
            const rightTile = createTile(type, rightPos);
            rightTile.userData.initialX = RIGHT_SIDE_X;
            
            updateEquationDisplay();
        }

        function checkForZeroPairs(movedTile) {
            const oppositeType = { 'x': '-x', '-x': 'x', '1': '-1', '-1': '1' };
            const typeToCheck = oppositeType[movedTile.userData.type];
            
            const sideTiles = tiles.filter(t => (t.position.x < 0 && movedTile.position.x < 0) || (t.position.x > 0 && movedTile.position.x > 0));

            for (const tile of sideTiles) {
                if (tile !== movedTile && tile.userData.type === typeToCheck) {
                    if (movedTile.position.distanceTo(tile.position) < 1.5) {
                        removeTile(movedTile);
                        removeTile(tile);
                        // Important: break loop after removing tiles as the array is modified
                        return; 
                    }
                }
            }
        }

        function reset() {
            // Clear all tiles
            [...tiles].forEach(tile => removeTile(tile));
            // Ensure draggableObjects is also cleared
            draggableObjects.length = 0;
            updateEquationDisplay();
        }
        
        // --- UI Helpers ---
        function showMessage(text) {
            const msgBox = document.getElementById('message-box');
            document.getElementById('message-text').textContent = text;
            msgBox.classList.remove('hidden');
        }

        function hideMessage() {
            document.getElementById('message-box').classList.add('hidden');
        }
        
        // --- Start ---
        init();
        // Set a default equation for demonstration
        document.getElementById('equation-input').value = '2x + 3 = x + 5';
        setEquationFromInput();

    </script>
</body>
</html>
